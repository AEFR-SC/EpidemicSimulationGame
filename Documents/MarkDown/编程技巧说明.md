# 编程技巧说明
## 1.使用`from`导入

首先，我使用了PyGame这个第三方模块

为了方便，我使用了`from pygame.locals import *`的方法导入，接下来`handleEvent`就会简洁许多。

看我的`handleEvent`:(部分)

```Python
for event in pygame.event.get():
    if event.type == pygame.QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):
        judgment = easygui.boolbox("是否退出游戏?", "注意", ["确定退出", "算了，再玩会儿"])
        if judgment:
            pygame.quit()
            sys.exit()
        else:
            ...
```

如果不是使用`from`导入，这里将会多写好多`pygame.locals`, 不仅麻烦，可读性也差。

``` Python
for event in pygame.event.get():
    if event.type == pygame.QUIT or (event.type == pygame.locals.KEYDOWN and event.key == pygame.locals.K_ESCAPE):
        judgment = easygui.boolbox("是否退出游戏?", "注意", ["确定退出", "算了，再玩会儿"])
        if judgment:
            pygame.quit()
            sys.exit()
        else:
            ...
```

## 2.面向对象

我将每一个圆点视为一个对象，这样就会很方便，随时可以调用相关数据：

```Python
class CharacterObject(object):
    """所有人物的父类"""

    def __init__(self, x, y, width, height, colour):
        self.attributeDict = {"People": {"Health": 0, "Symptoms": 1, "Asymptomatic": 2, "Death": 5},
                              "Doctor": {"Health": 3, "Symptoms": 4}}
        self.x = x  # x坐标
        self.y = y  # y坐标
        self.width = width  # 宽
        self.height = height  # 高
        self.life = 300  # 基础生命值
        self.immunity = random.randint(50, 100)  # 免疫力
        self.defensive = self.life + self.immunity  # 总防御值
        self.can_infectOther = True  # 能否感染他人
        self.infectedPeoples = 0  # 被self感染的人数
        self.infectedTime = None  # 被感染时的时间
        self.will_go_hospital = False  # 即将去医院
        self.in_hospital = False  # 在医院
        self.life_decline_lastTime = time.time()  # 上次减少生命值的时间
        self.rehabilitate_lastTime = time.time()  # 上次自我修复时的时间
        self.attribute = self.attributeDict["People"]["Health"]  # 属性
        self.colourDict = {"green": 0, "yellow": 1, "red": 2, "dh": 3, "ds": 4, "death": 5}  # 储存不同颜色
        self.colour = self.colourDict[colour]  # 确定颜色
        # 通过colour确定attribute以及image_path
        if colour == 0:
            self.attribute = self.attributeDict["People"]["Health"]
        if colour == 1:
            self.attribute = self.attributeDict["People"]["Asymptomatic"]
        if colour == 2:
            self.attribute = self.attributeDict["People"]["Symptoms"]
        if colour == 3:
            self.attribute = self.attributeDict["Doctor"]["Health"]
        if colour == 4:
            self.attribute = self.attributeDict["Doctor"]["Symptoms"]

        self.image_path = "..\\data\\images\\" + str(self.colour) + ".png"  # 图片路径
        self.load_image = pygame.image.load(self.image_path)  # 预加载图片

    def hit(self, component):  # 判断碰撞
        c = component
        return c.x > self.x - c.width and c.x < self.x + self.width and \
               c.y > self.y - c.height and c.y < self.y + self.height

    def paint(self):  # 绘制self
        canvas.blit(self.load_image, (self.x, self.y))

    def reset_pos(self):  # 重置坐标
        if self.x <= 70: self.x = random.randint(90, bgWidth - 50 - 20 - 20)
        if self.x >= bgWidth - 50 - 20: self.x = random.randint(90, bgWidth - 50 - 20 - 20)
        if self.y <= 20: self.y = random.randint(50, bgHeight - 50)
        if self.y >= bgHeight - 20: self.y = random.randint(50, bgHeight - 50)

    def CanInfectOther_qm(self):  # qm: question mark
        if self.infectedPeoples == GameVar.RO:
            self.can_infectOther = False

    def reloadImage(self):  # 重载图片
        self.image_path = self.image_path = "..\\data\\images\\" + str(self.colour) + ".png"
        self.load_image = pygame.image.load(self.image_path)

.............更多请阅读
```

- 继承

这是`CharcterObject`的部分代码，源码下面还有`Doctors` `Peoples`两个类都是继承`CharcterObject`的。



## 3.有关函数

我认为，能封装成函数/类的就绝不零零散散地写得乱七八糟。

比如，我将运行时需要用到的函数根据不同用途封装成了`generate` `componentPaint` `componentMove` `showData` `ChangingProperties` 等函数。

### 封装一些常用函数

比如在我的代码里有许多的`isActionTime` , 这就是个常用函数， 还有之前提到的`handleEvent`也属于常用函数。

isActionTime是这样的：

```Python
def isActionTime(lastTime, interval):
    currentTime = time.time()
    return currentTime - lastTime >= interval
```

一看就懂，是判断时间的。

在接下来的`componentPaint` 之类的函数里会经常用到这个`isActionTime`.

### 使用`controlState()`

以前，我经常会遇到一个问题：游戏的状态切换很困难，有时候还在`Start`时就开始运行了`Running`改运行的东西。我的解决办法是：使用一个`controlState`来控制状态，请看部分源码：

```Python
def controlState():
    if GameVar.state == GameVar.STATES["START"]:
        key = starter()
        if type(key) == str:
            GameVar.state = GameVar.STATES[key]
            print(key)
        handleEvent()

    if GameVar.state == GameVar.STATES["LOGIN"]:
        key = login()
        if type(key) == str:
            GameVar.state = GameVar.STATES[key]
            print(key)
        handleEvent()

    if GameVar.state == GameVar.STATES["RUNNING"]:
        handleEvent()
        componentPaint()
        componentMove()
        ChangingProperties()
        showData()
    if GameVar.state == GameVar.STATES["PAUSE"]:
        componentPaint()
```

通过部分代码， 可以看出这样的好处：

- 简介、明了、可读性高
- 逻辑清晰、不会感到混乱

**也就是说，这样的效率很高。**



## 4.减少全局变量

虽然Python不存在内存的问题，但是还是少用全局变量为妙。

为了减少全局变量，我使用了一个类`GameVar` (*`Var`*是*`Variable`*的简称)来存放变量，这样就只有少数全局变量(`bgWidth` `bgHeight` `one_day`等).



另外，这是一个比较另类的类，因为它不需要实例化：

```Python
class GameVar:
    Name = Value
```

`GameVar`差不多都是这种格式， 存放了`peoples` `patients`等十分重要的变量。

需要用到`GameVar`里面的变量时， 直接`GameVar.xxxx`即可。



## 5.关于Debug

调试一直都是一件让人头疼的事。我来介绍一下我主要使用的调试方法：

首先， 可以使用一个变量`Demo`, 当`Demo`为`“__main__”`时， 运行主程序。当`Demo`为`“demo”`时，运行你要调试的函数。



还可以使用PyCharm自带的Debug调试。 